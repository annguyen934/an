function mainMenu()
  local choices = gg.choice({
    "1. đặt chuồng mọi nơi",
    "2. ez arena",
    "3. luyen rank r",
    "4. ez resuce",
    "5.hack lv rong",
    "6.luyện skill",
    "7. Thoát"
  }, nil, "=== bố an vĩ đại vcl ===")

  if choices == 1 then
    antireload()
  elseif choices == 2 then
    arena()
  elseif choices == 3 then
    luyenrank()
  elseif choices == 4 then
    rescue()
    elseif choices == 5 then
    levr()
    elseif choices == 6 then
    luyensk()
  elseif choices == 7 then
    os.exit()
  else
    gg.toast("nguu")
  end
end

function antireload()
gg.setRanges(gg.REGION_C_ALLOC)
            gg.searchNumber("-300~300F;1 086 324 736;1 086 324 736::9", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1)
            gg.refineNumber("1 086 324 736", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1)
            gg.getResults(5000)
            gg.editAll("0", gg.TYPE_DWORD)
            gg.clearResults()
            gg.setRanges(gg.REGION_C_ALLOC)
            gg.searchNumber("-300~300F;1 084 227 584;1 084 227 584::9", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1)
            gg.refineNumber("1 084 227 584", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1)
            gg.getResults(5000)
            gg.editAll("0", gg.TYPE_DWORD)
            gg.clearResults()
            end

function arena()
  local input = gg.prompt(
    {
      "code rồng1:",
      "lev rồng 1:",
      "sao rồng 1:",
      "code rồng 2:",
      "lev rồng 2:",
      "sao rồng 2:",
      "code rồng 3:",
      "lev rồng 3:",
      "sao rồng 3:"
    },
    nil,
    {
      "number", "number", "number",
      "number", "number", "number",
      "number", "number", "number"
    }
  )

  if input == nil then
    gg.toast("ngu")
    return
  end

  local pattern = table.concat(input, ";") .. "::" -- Gộp thành chuỗi tìm kiếm
  gg.searchNumber(pattern, gg.TYPE_DWORD)
  gg.getResults(5000)
            gg.editAll("1011;1;0;1011;1;0;1011;1;0", gg.TYPE_DWORD)
  local ketQua = gg.getResultsCount()

  if ketQua > 0 then
    gg.toast("Đã tìm thấy " .. ketQua .. " kết quả.")
  else
    gg.alert("đéo tìm thấy mẹ gì")
    gg.getResults(5000)
            gg.editAll("1011;1;0;1011;1;0;1011;1;0", gg.TYPE_DWORD)
            gg.clearResults()
  end
end

function luyenrank()
  local input = gg.prompt(
    {
      "code rồng1:",
      "lev rồng 1:",
      "sao rồng 1:",
      "code rồng 2:",
      "lev rồng 2:",
      "sao rồng 2:",
      "code rồng 3:",
      "lev rồng 3:",
      "sao rồng 3:"
    },
    nil,
    {
      "number", "number", "number",
      "number", "number", "number",
      "number", "number", "number"
    }
  )

  if input == nil then
    gg.toast("ngu")
    return
  end

  local pattern = table.concat(input, ";") .. "::" -- Gộp thành chuỗi tìm kiếm
  gg.searchNumber(pattern, gg.TYPE_DWORD)
  gg.getResults(5000)
            gg.editAll("1011;1;0;1011;1;0;2644;3266;5", gg.TYPE_DWORD)
  local ketQua = gg.getResultsCount()

  if ketQua > 0 then
    gg.toast("Đã tìm thấy " .. ketQua .. " kết quả.")
  else
    gg.alert("đéo tìm thấy mẹ gì")
    gg.getResults(5000)
            gg.editAll("1011;1;0;1011;1;0;3266;3266;5", gg.TYPE_DWORD)
            gg.clearResults()
  end
  end

function rescue()
gg.clearResults()
    gg.setRanges(gg.REGION_C_ALLOC | gg.REGION_ANONYMOUS)
    gg.searchNumber("1000~5600;-1;10~70;0~5::17", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1, 0)
    gg.refineNumber("1000~5600;-1;10~70::10", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1, 0)
    gg.refineNumber("1000~5600;10~70::10", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1, 0)
    gg.getResults(99999)
    gg.editAll("1011;1", gg.TYPE_DWORD)
      gg.clearResults()
      end
function levr()
-- Hàm lấy dữ liệu rồng từ web
function fetchDragonData()
    local response = gg.makeRequest("https://raw.githubusercontent.com/annguyen934/an/refs/heads/main/dsrong")
    if not response or not response.content then
        gg.alert("Không tải được dữ liệu rồng!")
        return nil
    end
    local data = {}
    for line in response.content:gmatch("[^\r\n]+") do
        local code, name = line:match("^(%d+)%s*%-*%s*(.+)$")
        if code and name then
            table.insert(data, {code = tonumber(code), name = name})
        end
    end
    return #data > 0 and data or nil
end

-- Hàm lọc danh sách rồng theo tên nhập vào
function filterDragonList(data, keyword)
    local filtered = {}
    keyword = keyword:lower()
    for _, d in ipairs(data) do
        if d.name:lower():find(keyword, 1, true) then
            table.insert(filtered, d)
        end
    end
    return filtered
end

-- Hàm chọn rồng từ danh sách (show choice)
function chooseDragon(data)
    local list = {}
    for _, d in ipairs(data) do
        table.insert(list, d.code .. " - " .. d.name)
    end
    local choice = gg.choice(list, nil, "Chọn rồng:")
    if choice then
        return data[choice].code
    end
    return nil
end

-- Hàm nhập tên rồng, lọc danh sách rồi chọn
function inputAndChooseDragon()
    local data = fetchDragonData()
    if not data then return nil end

    local input = gg.prompt({"Nhập tên rồng để tìm:"}, {""}, {"text"})
    if not input then return nil end

    local filtered = filterDragonList(data, input[1])
    if #filtered == 0 then
        gg.alert("Không tìm thấy rồng nào phù hợp.")
        return nil
    end

    return chooseDragon(filtered)
end

-- Hàm chính
function main()
    local input1 = inputAndChooseDragon()
    if not input1 then return end

    gg.clearResults()
    gg.searchNumber(tostring(input1) .. ";-1;0::", gg.TYPE_DWORD)
    gg.refineNumber(tostring(input1), gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1)
    local results = gg.getResults(100)
    if #results == 0 then
        gg.alert("Không tìm thấy chuỗi cần tìm!")
        return
    end

    for i, v in ipairs(results) do
        if v.value == input1 then
            v.value = input1
        end
    end
    gg.setValues(results)

    local extra = {}
    for i, v in ipairs(results) do
        table.insert(extra, {
            address = v.address + 4 * 3,
            flags = gg.TYPE_DWORD,
            value = i
        })
    end
    gg.setValues(extra)
    gg.toast("Đã xử lý xong mã rồng: " .. input1)
end

main()
end
function luyensk()
  local skillChoice = gg.choice({
    "1. Luyện Skill 1",
    "2. Luyện Skill 2",
    "3. Luyện Skill 3",
    "4. Luyện Skill 4"
  }, nil, "Lên web mà tra code rồng")

  if skillChoice == 1 then
    skilldau()
  elseif skillChoice == 2 then
    skillhai()
  elseif skillChoice == 3 then
    skillba()
  elseif skillChoice == 4 then
    skillbon()
  else
    gg.toast("cmm đéo chọn à")
  end
end
    function skilldau()
    gg.alert("luyện skill 1")

-- Lấy dữ liệu rồng từ trang web
-- Biến toàn cục
local started = false
local input1Global = nil
local input2Global = nil
local waitingForInput2 = false

-- Lấy dữ liệu rồng từ trang web
function fetchDragonData()
    local response = gg.makeRequest("https://raw.githubusercontent.com/annguyen934/an/refs/heads/main/dsrong")
    if not response or not response.content then
        gg.alert("Không tải được dữ liệu rồng!")
        return nil
    end
    local data = {}
    for line in response.content:gmatch("[^\r\n]+") do
        local code, name = line:match("^(%d+)%s*%-*%s*(.+)$")
        if code and name then
            table.insert(data, {code = tonumber(code), name = name})
        end
    end
    return #data > 0 and data or nil
end

-- Chỉ gọi hộp thoại tìm kiếm khi user nhấn lại GG
function searchDragonCode(data, title)
    local input = gg.prompt({title or "Nhập tên rồng:"}, {""}, {"text"})
    if not input then return nil end
    local searchTerm = input[1]:lower()
    local list, codes = {}, {}
    for _, d in ipairs(data) do
        if d.name:lower():find(searchTerm, 1, true) then
            table.insert(list, d.code .. " - " .. d.name)
            table.insert(codes, d.code)
        end
    end
    if #list == 0 then
        gg.alert("Không tìm thấy rồng!")
        return nil
    end
    local choice = gg.choice(list, nil, title or "Chọn rồng:")
    return choice and tonumber(codes[choice]) or nil
end

-- Xử lý input1: tìm chuỗi, lọc, sửa 1011+
function handleInput1AndReplace()
    local data = fetchDragonData()
    if not data then return nil end

    input1Global = searchDragonCode(data, "Tìm rồng đầu tiên (input1):")
    if not input1Global then
        gg.toast("Hủy input1, nhấn lại GG để tiếp tục.")
        return
    end

    gg.clearResults()
    local searchStr = tostring(input1Global) .. ";-1;0::"
    gg.searchNumber(searchStr, gg.TYPE_DWORD)
    gg.refineNumber(tostring(input1Global), gg.TYPE_DWORD)

    local results = gg.getResults(500)
    if #results == 0 then
        gg.alert("Không tìm thấy chuỗi input1!")
        return
    end

    -- Sửa thành 1011, 1012,...
    for i = 1, #results do
        results[i].value = 1010 + i
    end
    gg.setValues(results)

    gg.setVisible(false)
    started = true
    waitingForInput2 = true
    gg.toast("Xong input1. Mở GG để tiếp tục input2.")
end

-- Khi mở lại GG: chọn input2, thay thế, sao chép offset 12 -> 13,14,15
function handleInput2AndCopyOffsets()
    local data = fetchDragonData()
    if not data then return end

    input2Global = searchDragonCode(data, "Tìm rồng thứ hai (input2):")
    if not input2Global then
        gg.toast("Hủy input2, mở lại GG để tiếp tục.")
        return
    end

    gg.refineNumber(tostring(input2Global), gg.TYPE_DWORD)
    local results = gg.getResults(500)
    if #results == 0 then
        gg.alert("Không tìm thấy input2 trong bộ nhớ!")
        return
    end

    for i = 1, #results do
        results[i].value = input1Global
    end
    gg.setValues(results)

    local baseEntry = nil
    for _, r in ipairs(results) do
        if r.value == input1Global then
            baseEntry = r
            break
        end
    end
    if not baseEntry then
        gg.alert("Không tìm thấy địa chỉ chứa input1!")
        return
    end

    gg.gotoAddress(baseEntry.address)

    local addr = baseEntry.address
    local offset12 = addr + 4 * 12
    local offset13 = addr + 4 * 13
    local offset14 = addr + 4 * 14
    local offset15 = addr + 4 * 15

    -- Copy offset 12 -> 13,14,15
    local val12 = gg.getValues({{address = offset12, flags = gg.TYPE_DWORD}})[1].value

    local toWrite = {
        {address = offset13, flags = gg.TYPE_DWORD, value = val12},
        {address = offset14, flags = gg.TYPE_DWORD, value = val12},
        {address = offset15, flags = gg.TYPE_DWORD, value = val12},
    }

    gg.setValues(toWrite)
    gg.toast("Đã copy offset 12 vào 13,14,15.")
    started = false
    waitingForInput2 = false
    input1Global = nil
    input2Global = nil
end

-- Chạy lần đầu
handleInput1AndReplace()

-- Lặp đợi GG hiện lại
while true do
    if gg.isVisible(true) then
        gg.setVisible(false)
        if started and waitingForInput2 then
            handleInput2AndCopyOffsets()
        elseif not started then
            handleInput1AndReplace()
        end
        end
        end
    end
function skillhai()
gg.alert("luyện skill 2")

-- Lấy dữ liệu rồng từ trang web
-- Biến toàn cục
local started = false
local input1Global = nil
local input2Global = nil
local waitingForInput2 = false

-- Lấy dữ liệu rồng từ trang web
function fetchDragonData()
    local response = gg.makeRequest("https://raw.githubusercontent.com/annguyen934/an/refs/heads/main/dsrong")
    if not response or not response.content then
        gg.alert("Không tải được dữ liệu rồng!")
        return nil
    end
    local data = {}
    for line in response.content:gmatch("[^\r\n]+") do
        local code, name = line:match("^(%d+)%s*%-*%s*(.+)$")
        if code and name then
            table.insert(data, {code = tonumber(code), name = name})
        end
    end
    return #data > 0 and data or nil
end

-- Hộp thoại tìm kiếm rồng
function searchDragonCode(data, title)
    local input = gg.prompt({title or "Nhập tên rồng:"}, {""}, {"text"})
    if not input then return nil end
    local searchTerm = input[1]:lower()
    local list, codes = {}, {}
    for _, d in ipairs(data) do
        if d.name:lower():find(searchTerm, 1, true) then
            table.insert(list, d.code .. " - " .. d.name)
            table.insert(codes, d.code)
        end
    end
    if #list == 0 then
        gg.alert("Không tìm thấy rồng!")
        return nil
    end
    local choice = gg.choice(list, nil, title or "Chọn rồng:")
    return choice and tonumber(codes[choice]) or nil
end

-- Xử lý input1: tìm chuỗi, lọc, sửa 1011+
function handleInput1AndReplace()
    local data = fetchDragonData()
    if not data then return nil end

    input1Global = searchDragonCode(data, "Tìm rồng đầu tiên (input1):")
    if not input1Global then
        gg.toast("Hủy input1, nhấn lại GG để tiếp tục.")
        return
    end

    gg.clearResults()
    local searchStr = tostring(input1Global) .. ";-1;0::"
    gg.searchNumber(searchStr, gg.TYPE_DWORD)
    gg.refineNumber(tostring(input1Global), gg.TYPE_DWORD)

    local results = gg.getResults(500)
    if #results == 0 then
        gg.alert("Không tìm thấy chuỗi input1!")
        return
    end

    -- Sửa thành 1011, 1012,...
    for i = 1, #results do
        results[i].value = 1010 + i
    end
    gg.setValues(results)

    gg.setVisible(false)
    started = true
    waitingForInput2 = true
    gg.toast("Xong input1. Mở GG để tiếp tục input2.")
end

-- Khi mở lại GG: chọn input2, thay thế, sao chép offset 13 → 12,14,15
function handleInput2AndCopyOffsets()
    local data = fetchDragonData()
    if not data then return end

    input2Global = searchDragonCode(data, "Tìm rồng thứ hai (input2):")
    if not input2Global then
        gg.toast("Hủy input2, mở lại GG để tiếp tục.")
        return
    end

    gg.refineNumber(tostring(input2Global), gg.TYPE_DWORD)
    local results = gg.getResults(500)
    if #results == 0 then
        gg.alert("Không tìm thấy input2 trong bộ nhớ!")
        return
    end

    for i = 1, #results do
        results[i].value = input1Global
    end
    gg.setValues(results)

    local baseEntry = nil
    for _, r in ipairs(results) do
        if r.value == input1Global then
            baseEntry = r
            break
        end
    end
    if not baseEntry then
        gg.alert("Không tìm thấy địa chỉ chứa input1!")
        return
    end

    gg.gotoAddress(baseEntry.address)

    local addr = baseEntry.address
    local offset12 = addr + 4 * 12
    local offset13 = addr + 4 * 13
    local offset14 = addr + 4 * 14
    local offset15 = addr + 4 * 15

    -- Copy offset 13 → dán vào 12,14,15
    local val13 = gg.getValues({{address = offset13, flags = gg.TYPE_DWORD}})[1].value

    local toWrite = {
        {address = offset12, flags = gg.TYPE_DWORD, value = val13},
        {address = offset14, flags = gg.TYPE_DWORD, value = val13},
        {address = offset15, flags = gg.TYPE_DWORD, value = val13},
    }

    gg.setValues(toWrite)
    gg.toast("Đã copy offset 13 vào 12,14,15.")
    started = false
    waitingForInput2 = false
    input1Global = nil
    input2Global = nil
end

-- Chạy lần đầu
handleInput1AndReplace()

-- Lặp chờ mở lại GG
while true do
    if gg.isVisible(true) then
        gg.setVisible(false)
        if started and waitingForInput2 then
            handleInput2AndCopyOffsets()
        elseif not started then
            handleInput1AndReplace()
        end
    end
end
end
function skillba()
gg.alert("skill 3")

-- -- Biến toàn cục
local started = false
local input1Global = nil
local input2Global = nil
local waitingForInput2 = false

-- Lấy dữ liệu rồng từ trang web
function fetchDragonData()
    local response = gg.makeRequest("https://raw.githubusercontent.com/annguyen934/an/refs/heads/main/dsrong")
    if not response or not response.content then
        gg.alert("Không tải được dữ liệu rồng!")
        return nil
    end
    local data = {}
    for line in response.content:gmatch("[^\r\n]+") do
        local code, name = line:match("^(%d+)%s*%-*%s*(.+)$")
        if code and name then
            table.insert(data, {code = tonumber(code), name = name})
        end
    end
    return #data > 0 and data or nil
end

-- Hộp thoại tìm kiếm rồng
function searchDragonCode(data, title)
    local input = gg.prompt({title or "Nhập tên rồng:"}, {""}, {"text"})
    if not input then return nil end
    local searchTerm = input[1]:lower()
    local list, codes = {}, {}
    for _, d in ipairs(data) do
        if d.name:lower():find(searchTerm, 1, true) then
            table.insert(list, d.code .. " - " .. d.name)
            table.insert(codes, d.code)
        end
    end
    if #list == 0 then
        gg.alert("Không tìm thấy rồng!")
        return nil
    end
    local choice = gg.choice(list, nil, title or "Chọn rồng:")
    return choice and tonumber(codes[choice]) or nil
end

-- Xử lý input1: tìm chuỗi, lọc, sửa 1011+
function handleInput1AndReplace()
    local data = fetchDragonData()
    if not data then return nil end

    input1Global = searchDragonCode(data, "Tìm rồng đầu tiên (input1):")
    if not input1Global then
        gg.toast("Hủy input1, nhấn lại GG để tiếp tục.")
        return
    end

    gg.clearResults()
    local searchStr = tostring(input1Global) .. ";-1;0::"
    gg.searchNumber(searchStr, gg.TYPE_DWORD)
    gg.refineNumber(tostring(input1Global), gg.TYPE_DWORD)

    local results = gg.getResults(500)
    if #results == 0 then
        gg.alert("Không tìm thấy chuỗi input1!")
        return
    end

    -- Sửa thành 1011, 1012,...
    for i = 1, #results do
        results[i].value = 1010 + i
    end
    gg.setValues(results)

    gg.setVisible(false)
    started = true
    waitingForInput2 = true
    gg.toast("Xong input1. Mở GG để tiếp tục input2.")
end

-- Khi mở lại GG: chọn input2, thay thế, sao chép offset 14 → 12,13,15
function handleInput2AndCopyOffsets()
    local data = fetchDragonData()
    if not data then return end

    input2Global = searchDragonCode(data, "Tìm rồng thứ hai (input2):")
    if not input2Global then
        gg.toast("Hủy input2, mở lại GG để tiếp tục.")
        return
    end

    gg.refineNumber(tostring(input2Global), gg.TYPE_DWORD)
    local results = gg.getResults(500)
    if #results == 0 then
        gg.alert("Không tìm thấy input2 trong bộ nhớ!")
        return
    end

    for i = 1, #results do
        results[i].value = input1Global
    end
    gg.setValues(results)

    local baseEntry = nil
    for _, r in ipairs(results) do
        if r.value == input1Global then
            baseEntry = r
            break
        end
    end
    if not baseEntry then
        gg.alert("Không tìm thấy địa chỉ chứa input1!")
        return
    end

    gg.gotoAddress(baseEntry.address)

    local addr = baseEntry.address
    local offset12 = addr + 4 * 12
    local offset13 = addr + 4 * 13
    local offset14 = addr + 4 * 14
    local offset15 = addr + 4 * 15

    -- Copy offset 14 → dán vào 12,13,15
    local val14 = gg.getValues({{address = offset14, flags = gg.TYPE_DWORD}})[1].value

    local toWrite = {
        {address = offset12, flags = gg.TYPE_DWORD, value = val14},
        {address = offset13, flags = gg.TYPE_DWORD, value = val14},
        {address = offset15, flags = gg.TYPE_DWORD, value = val14},
    }

    gg.setValues(toWrite)
    gg.toast("Đã copy offset 14 vào 12,13,15.")
    started = false
    waitingForInput2 = false
    input1Global = nil
    input2Global = nil
end

-- Chạy lần đầu
handleInput1AndReplace()

-- Lặp chờ mở lại GG
while true do
    if gg.isVisible(true) then
        gg.setVisible(false)
        if started and waitingForInput2 then
            handleInput2AndCopyOffsets()
        elseif not started then
            handleInput1AndReplace()
        end
    end
end
end
function skillbon()
gg.alert("skill 4")

-- Lấy dữ liệu rồng từ trang web
-- Biến toàn cục
local started = false
local input1Global = nil
local input2Global = nil
local waitingForInput2 = false

-- Lấy dữ liệu rồng từ trang web
function fetchDragonData()
    local response = gg.makeRequest("https://raw.githubusercontent.com/annguyen934/an/refs/heads/main/dsrong")
    if not response or not response.content then
        gg.alert("Không tải được dữ liệu rồng!")
        return nil
    end
    local data = {}
    for line in response.content:gmatch("[^\r\n]+") do
        local code, name = line:match("^(%d+)%s*%-*%s*(.+)$")
        if code and name then
            table.insert(data, {code = tonumber(code), name = name})
        end
    end
    return #data > 0 and data or nil
end

-- Chỉ gọi hộp thoại tìm kiếm khi user nhấn lại GG (không lặp ngay)
function searchDragonCode(data, title)
    local input = gg.prompt({title or "Nhập tên rồng:"}, {""}, {"text"})
    if not input then return nil end
    local searchTerm = input[1]:lower()
    local list, codes = {}, {}
    for _, d in ipairs(data) do
        if d.name:lower():find(searchTerm, 1, true) then
            table.insert(list, d.code .. " - " .. d.name)
            table.insert(codes, d.code)
        end
    end
    if #list == 0 then
        gg.alert("Không tìm thấy rồng!")
        return nil
    end
    local choice = gg.choice(list, nil, title or "Chọn rồng:")
    return choice and tonumber(codes[choice]) or nil
end

-- Xử lý input1: tìm chuỗi, lọc, sửa 1011+
function handleInput1AndReplace()
    local data = fetchDragonData()
    if not data then return nil end

    input1Global = searchDragonCode(data, "Tìm rồng đầu tiên (input1):")
    if not input1Global then
        gg.toast("Hủy input1, nhấn lại GG để tiếp tục.")
        return
    end

    gg.clearResults()
    local searchStr = tostring(input1Global) .. ";-1;0::"
    gg.searchNumber(searchStr, gg.TYPE_DWORD)
    gg.refineNumber(tostring(input1Global), gg.TYPE_DWORD)

    local results = gg.getResults(500)
    if #results == 0 then
        gg.alert("Không tìm thấy chuỗi input1!")
        return
    end

    -- Sửa thành 1011, 1012,...
    for i = 1, #results do
        results[i].value = 1010 + i
    end
    gg.setValues(results)

    gg.setVisible(false)
    started = true
    waitingForInput2 = true
    gg.toast("Xong input1. Mở GG để tiếp tục input2.")
end

-- Khi mở lại GG: chọn input2, thay thế, sao chép offset
function handleInput2AndCopyOffsets()
    local data = fetchDragonData()
    if not data then return end

    input2Global = searchDragonCode(data, "Tìm rồng thứ hai (input2):")
    if not input2Global then
        gg.toast("Hủy input2, mở lại GG để tiếp tục.")
        return
    end

    gg.refineNumber(tostring(input2Global), gg.TYPE_DWORD)
    local results = gg.getResults(500)
    if #results == 0 then
        gg.alert("Không tìm thấy input2 trong bộ nhớ!")
        return
    end

    for i = 1, #results do
        results[i].value = input1Global
    end
    gg.setValues(results)

    local baseEntry = nil
    for _, r in ipairs(results) do
        if r.value == input1Global then
            baseEntry = r
            break
        end
    end
    if not baseEntry then
        gg.alert("Không tìm thấy địa chỉ chứa input1!")
        return
    end

    gg.gotoAddress(baseEntry.address)

    local addr = baseEntry.address
    local offset12 = addr + 4 * 12
    local offset13 = addr + 4 * 13
    local offset14 = addr + 4 * 14
    local offset15 = addr + 4 * 15

    local val15 = gg.getValues({{address = offset15, flags = gg.TYPE_DWORD}})[1].value

    local toWrite = {
        {address = offset12, flags = gg.TYPE_DWORD, value = val15},
        {address = offset13, flags = gg.TYPE_DWORD, value = val15},
        {address = offset14, flags = gg.TYPE_DWORD, value = val15},
    }

    gg.setValues(toWrite)
    gg.toast("Đã copy offset 15 vào 12,13,14.")
    started = false
    waitingForInput2 = false
    input1Global = nil
    input2Global = nil
end

-- Chạy lần đầu
handleInput1AndReplace()

-- Lặp đợi GG hiện lại
while true do
    if gg.isVisible(true) then
        gg.setVisible(false)
        if started and waitingForInput2 then
            handleInput2AndCopyOffsets()
        elseif not started then
            handleInput1AndReplace()
        end
    end
end

main()

while true do
    if gg.isVisible(true) and started then
        gg.setVisible(false)
        onGGVisible(input1Global)
        started = false
    end
end
  end
-- Chạy menu
while true do
  if gg.isVisible(true) then
    gg.setVisible(false)
    mainMenu()
  end
  end

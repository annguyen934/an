function mainMenu()
  local choices = gg.choice({
    "1. ƒë·∫∑t chu·ªìng m·ªçi n∆°i",
    "2. ez arena",
    "3. luyen rank r",
    "4. ez resuce",
    "5.hack lv rong",
    "6.luy·ªán skill",
    "7.heroicskip",
    "8. Tho√°t"
  }, nil, "=== b·ªë an vƒ© ƒë·∫°i vcl ===")

  if choices == 1 then
    antireload()
  elseif choices == 2 then
    arena()
  elseif choices == 3 then
    luyenrank()
  elseif choices == 4 then
    rescue()
    elseif choices == 5 then
    levr()
    elseif choices == 6 then
    luyensk()
    elseif choices == 7 then
    TimeJump()
  elseif choices == 8 then
    os.exit()
  else
    gg.toast("nguu")
  end
end

function antireload()
gg.setRanges(gg.REGION_C_ALLOC)
            gg.searchNumber("-300~300F;1 086 324 736;1 086 324 736::9", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1)
            gg.refineNumber("1 086 324 736", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1)
            gg.getResults(5000)
            gg.editAll("0", gg.TYPE_DWORD)
            gg.clearResults()
            gg.setRanges(gg.REGION_C_ALLOC)
            gg.searchNumber("-300~300F;1 084 227 584;1 084 227 584::9", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1)
            gg.refineNumber("1 084 227 584", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1)
            gg.getResults(5000)
            gg.editAll("0", gg.TYPE_DWORD)
            gg.clearResults()
            end

function arena()
progress = progress or 1
inputs = inputs or {}

function fetchDragonData()
    local response = gg.makeRequest("https://raw.githubusercontent.com/annguyen934/an/refs/heads/main/dsrong")
    if not response or not response.content then
        gg.alert("Kh√¥ng t·∫£i ƒë∆∞·ª£c d·ªØ li·ªáu r·ªìng!")
        return nil
    end
    local data = {}
    for line in response.content:gmatch("[^\r\n]+") do
        local code, name = line:match("^(%d+)%s*%-*%s*(.+)$")
        if code and name then
            table.insert(data, {code = tonumber(code), name = name})
        end
    end
    return data
end

function searchDragon(data)
    while true do
        local input = gg.prompt({"üîç Nh·∫≠p t√™n r·ªìng ƒë·ªÉ t√¨m:"}, {""}, {"text"})
        if not input then return nil end
        local searchTerm = input[1]:lower()
        local choices, codes = {}, {}
        for _, d in ipairs(data) do
            if d.name:lower():find(searchTerm, 1, true) then
                table.insert(choices, d.code .. " - " .. d.name)
                table.insert(codes, d.code)
            end
        end
        if #choices == 0 then
            gg.alert("Kh√¥ng t√¨m th·∫•y r·ªìng.")
        else
            local sel = gg.choice(choices, nil, "üü¢ Ch·ªçn r·ªìng:")
            if sel then return tonumber(codes[sel]) end
        end
    end
end

function inputNumber(label)
    while true do
        local input = gg.prompt({label}, {""}, {"number"})
        if not input then return nil end
        local num = tonumber(input[1])
        if num then return num end
        gg.alert("Vui l√≤ng nh·∫≠p s·ªë h·ª£p l·ªá.")
    end
end

function collectInputs()
    local data = fetchDragonData()
    if not data then return end

    while progress <= 6 do
        if progress % 2 == 1 then
            local dragon = searchDragon(data)
            if dragon then
                inputs[progress] = dragon
                progress = progress + 1
            else
                return
            end
        else
            local number = inputNumber("Nh·∫≠p s·ªë #" .. progress .. ":")
            if number then
                inputs[progress] = number
                progress = progress + 1
            else
                return
            end
        end
    end
end

function applyChanges()
    local search = table.concat(inputs, ";") .. "::"
    gg.clearResults()
    gg.searchNumber(search, gg.TYPE_DWORD)
    local results = gg.getResults(1000)
    if #results < 6 then
        gg.alert("Kh√¥ng t√¨m th·∫•y ƒë·ªß k·∫øt qu·∫£.")
        return
    end

    for i = 0, #results - 1, 6 do
        local group = {}
        for j = 0, 5 do
            local idx = i + j + 1
            if results[idx] then
                table.insert(group, {
                    address = results[idx].address,
                    flags = gg.TYPE_DWORD,
                    value = (j % 2 == 0) and 1011 or 1,
                    freeze = true
                })
            end
        end
        gg.addListItems(group)
    end

    gg.toast("‚úÖ ƒê√£ s·ª≠a v√† freeze t·∫•t c·∫£.")
end

-- B·∫Øt ƒë·∫ßu v√≤ng l·∫∑p gi√°m s√°t GG
gg.toast("Script b·∫Øt ƒë·∫ßu. M·ªü GG ƒë·ªÉ nh·∫≠p d·ªØ li·ªáu.")
while true do
    if gg.isVisible(true) then
        gg.setVisible(false)
        if progress <= 6 then
            collectInputs()
        end
        if progress > 6 then
            applyChanges()
            gg.alert("Ho√†n th√†nh. M·ªü l·∫°i GG ƒë·ªÉ ch·∫°y l·∫°i.")
            -- N·∫øu mu·ªën ch·∫°y l·∫°i th√¨ reset:
            progress = 1
            inputs = {}
        end
    end
    gg.sleep(100)
end
end
function TimeJump()
-- H√†m No Restart
function TimeJumpFunc()
  gg.setRanges(gg.REGION_CODE_APP)
  gg.searchNumber("Q 'error'", gg.TYPE_BYTE)
  local results = gg.getResults(100000)
  if #results > 0 then
    gg.editAll("0", gg.TYPE_BYTE)
    gg.toast("‚úÖ No Restart ƒë√£ ƒë∆∞·ª£c b·∫≠t.")
  else
    gg.toast("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y gi√° tr·ªã No Restart.")
  end
  gg.clearResults()
end

-- H√†m Speed all
function ngu()
  gg.setRanges(gg.REGION_C_ALLOC)
  gg.searchNumber("-2000000000~-1000000000;2;300~86400;0::13", gg.TYPE_DWORD)
  gg.refineNumber("3~1000000", gg.TYPE_DWORD)
  local results = gg.getResults(10000)
  if #results > 0 then
    gg.editAll("0", gg.TYPE_DWORD)
    gg.toast("‚úÖ ƒê√£ b·∫≠t Speed all.")
  else
    gg.toast("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y gi√° tr·ªã Speed all.")
  end
  gg.clearResults()
end

-- H√†m ch·ªânh th·ªùi gian c·ª• th·ªÉ
function editTime(seconds)
  gg.setRanges(gg.REGION_C_ALLOC)
  gg.searchNumber(tostring(seconds), gg.TYPE_DWORD)
  gg.refineNumber(tostring(seconds), gg.TYPE_DWORD)
  local results = gg.getResults(10000)
  if #results > 0 then
    gg.editAll("0", gg.TYPE_DWORD)
    gg.toast("‚úÖ ƒê√£ ch·ªânh th·ªùi gian: " .. seconds .. " gi√¢y")
  else
    gg.toast("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y gi√° tr·ªã " .. seconds .. " gi√¢y.")
  end
  gg.clearResults()
end

-- Main menu ch·ªçn ƒëa l·ª±a ch·ªçn
local TimeJump = gg.multiChoice({
  'üëø No Restart üëø',
  'üèÉ‚Äç‚ôÇÔ∏è Speed all üèÉ‚Äç‚ôÇÔ∏è',
  'üèÉ‚Äç‚ôÇÔ∏è 5min üèÉ‚Äç‚ôÇÔ∏è',
  'üèÉ‚Äç‚ôÇÔ∏è 15min üèÉ‚Äç‚ôÇÔ∏è',
  'üèÉ‚Äç‚ôÇÔ∏è 30min üèÉ‚Äç‚ôÇÔ∏è',
  'üèÉ‚Äç‚ôÇÔ∏è 1hour üèÉ‚Äç‚ôÇÔ∏è',
  'üèÉ‚Äç‚ôÇÔ∏è 1hour 20min üèÉ‚Äç‚ôÇÔ∏è',
  'üèÉ‚Äç‚ôÇÔ∏è 3hour üèÉ‚Äç‚ôÇÔ∏è',
  'üèÉ‚Äç‚ôÇÔ∏è 6hour 40min üèÉ‚Äç‚ôÇÔ∏è',
  'üèÉ‚Äç‚ôÇÔ∏è 8hour üèÉ‚Äç‚ôÇÔ∏è'
}, nil, "üïì n√≥ ch·∫°y xong thif ch·ªù t·∫ßm 20s h√£y ƒë√°nh ƒë√°nh xong 1 l·∫ßn th√¨ ch·ªù t·∫ßm 5s r·ªìi out game v√¥ l·∫°i):")

if TimeJump == nil or next(TimeJump) == nil then
  gg.toast("‚ùå ƒê√£ h·ªßy thao t√°c ho·∫∑c kh√¥ng ch·ªçn g√¨.")
  return
end

for i, selected in pairs(TimeJump) do
  if selected then
    if i == 1 then
      TimeJumpFunc()
    elseif i == 2 then
      ngu()
    elseif i >= 3 then
      local times = {300, 900, 1800, 3600, 4800, 10800, 24000, 28800}
      editTime(times[i-2])
    end
  end
end

gg.toast("‚úÖ ƒê√£ th·ª±c hi·ªán xong c√°c thao t√°c th·ªùi gian.")
end
function luyenrank()
local state = {
  step = 1,
  input1 = nil, input2 = nil, input3 = nil,
  input4 = nil, input5 = nil, input6 = nil,
  input7 = nil, input8 = nil, input9 = nil,
  input10 = nil
}

function fetchDragonData()
  local response = gg.makeRequest("https://raw.githubusercontent.com/annguyen934/an/refs/heads/main/dsrong")
  if not response or not response.content then
    gg.alert("Kh√¥ng t·∫£i ƒë∆∞·ª£c d·ªØ li·ªáu r·ªìng!")
    return nil
  end
  local data = {}
  for line in response.content:gmatch("[^\r\n]+") do
    local code, name = line:match("^(%d+)%s*%-*%s*(.+)$")
    if code and name then
      table.insert(data, {code = tonumber(code), name = name})
    end
  end
  return data
end

function searchAndChooseDragon()
  local data = fetchDragonData()
  if not data then return nil end
  local input = gg.prompt({"r·ªìng:"},{""},{"text"},{"r·ªìng2 :"},{""},{"text"},{"r·ªìng3 :"},{""},{"text"},{"r·ªìng ƒë·ªïi :"},{""},{"text"})
  if not input then return nil end

  local searchTerm = input[1]:lower()
  local filtered, codes = {}, {}
  for _, d in ipairs(data) do
    if d.name:lower():find(searchTerm, 1, true) then
      table.insert(filtered, d.code .. " - " .. d.name)
      table.insert(codes, d.code)
    end
  end

  if #filtered == 0 then
    gg.alert("Kh√¥ng t√¨m th·∫•y r·ªìng ph√π h·ª£p.")
    return nil
  end

  local choice = gg.choice(filtered, nil, "Ch·ªçn r·ªìng:")
  return choice and tonumber(codes[choice]) or nil
end

function doSearchAndEdit()
  -- T·∫°o chu·ªói t√¨m ki·∫øm d·∫°ng: "input1;input2;input3;input4;input5;input6;input7;input8;input9::"
  local searchString = string.format(
    "%d;%d;%d;%d;%d;%d;%d;%d;%d::",
    state.input1, state.input2, state.input3,
    state.input4, state.input5, state.input6,
    state.input7, state.input8, state.input9
  )

  gg.clearResults()
  gg.searchNumber(searchString, gg.TYPE_DWORD)
  local results = gg.getResults(9)
  if #results == 9 then
    -- Gi√° tr·ªã s·ª≠a th√†nh: 1011;1;0;1011;1;0;input10;3266;5
    local newValues = {
      1011, 1, 0,
      1011, 1, 0,
      state.input10 or 0, 3266, 5
    }
    for i = 1, 9 do
      results[i].value = newValues[i]
    end
    gg.setValues(results)
    gg.alert("ƒê√£ thay ƒë·ªïi v√† freeze th√†nh c√¥ng!")
  else
    gg.alert("Kh√¥ng t√¨m th·∫•y ƒë·ªß 9 gi√° tr·ªã!")
  end
end

function runStep()
  while true do
    if state.step == 1 then
      local val = searchAndChooseDragon()
      if val then
        state.input1 = val
        state.step = 2
      else return end

    elseif state.step == 2 then
      local input = gg.prompt({"lev r·ªìng 1 (s·ªë)", "sao r·ªìng1 (s·ªë)"}, nil, {"number", "number"})
      if input then
        state.input2 = tonumber(input[1])
        state.input3 = tonumber(input[2])
        state.step = 3
      else return end

    elseif state.step == 3 then
      local val = searchAndChooseDragon()
      if val then
        state.input4 = val
        state.step = 4
      else return end

    elseif state.step == 4 then
      local input = gg.prompt({"lev r·ªìng 2 (s·ªë)", "sao r·ªìng 2 (s·ªë)"}, nil, {"number", "number"})
      if input then
        state.input5 = tonumber(input[1])
        state.input6 = tonumber(input[2])
        state.step = 5
      else return end

    elseif state.step == 5 then
      local val = searchAndChooseDragon()
      if val then
        state.input7 = val
        state.step = 6
      else return end

    elseif state.step == 6 then
      local input = gg.prompt({"lev r·ªìng 3 (s·ªë)", "sao r·ªìng 3 (s·ªë)"}, nil, {"number", "number"})
      if input then
        state.input8 = tonumber(input[1])
        state.input9 = tonumber(input[2])
        state.step = 7
      else return end

    elseif state.step == 7 then
      local val = searchAndChooseDragon()
      if val then
        state.input10 = val
        state.step = 8
      else return end

    elseif state.step == 8 then
      doSearchAndEdit()
      state.step = 999
      return
    else
      return
    end
  end
end

gg.toast("Kh·ªüi ƒë·ªông script. M·ªü l·∫°i GG ƒë·ªÉ ti·∫øp t·ª•c n·∫øu tho√°t gi·ªØa ch·ª´ng.")

while true do
  if gg.isVisible(true) then
    gg.setVisible(false)
    if state.step < 999 then
      runStep()
    else
      gg.toast("Script ƒë√£ ho√†n th√†nh!")
    end
  end
end
end
function rescue()
gg.clearResults()
    gg.setRanges(gg.REGION_C_ALLOC | gg.REGION_ANONYMOUS)
    gg.searchNumber("1000~5600;-1;10~70;0~5::17", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1, 0)
    gg.refineNumber("1000~5600;-1;10~70::10", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1, 0)
    gg.refineNumber("1000~5600;10~70::10", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1, 0)
    gg.getResults(99999)
    gg.editAll("1011;1", gg.TYPE_DWORD)
      gg.clearResults()
      end
function levr()
-- H√†m l·∫•y d·ªØ li·ªáu r·ªìng t·ª´ web
function fetchDragonData()
    local response = gg.makeRequest("https://raw.githubusercontent.com/annguyen934/an/refs/heads/main/dsrong")
    if not response or not response.content then
        gg.alert("Kh√¥ng t·∫£i ƒë∆∞·ª£c d·ªØ li·ªáu r·ªìng!")
        return nil
    end
    local data = {}
    for line in response.content:gmatch("[^\r\n]+") do
        local code, name = line:match("^(%d+)%s*%-*%s*(.+)$")
        if code and name then
            table.insert(data, {code = tonumber(code), name = name})
        end
    end
    return #data > 0 and data or nil
end

-- H√†m l·ªçc danh s√°ch r·ªìng theo t√™n nh·∫≠p v√†o
function filterDragonList(data, keyword)
    local filtered = {}
    keyword = keyword:lower()
    for _, d in ipairs(data) do
        if d.name:lower():find(keyword, 1, true) then
            table.insert(filtered, d)
        end
    end
    return filtered
end

-- H√†m ch·ªçn r·ªìng t·ª´ danh s√°ch (show choice)
function chooseDragon(data)
    local list = {}
    for _, d in ipairs(data) do
        table.insert(list, d.code .. " - " .. d.name)
    end
    local choice = gg.choice(list, nil, "Ch·ªçn r·ªìng:")
    if choice then
        return data[choice].code
    end
    return nil
end

-- H√†m nh·∫≠p t√™n r·ªìng, l·ªçc danh s√°ch r·ªìi ch·ªçn
function inputAndChooseDragon()
    local data = fetchDragonData()
    if not data then return nil end

    local input = gg.prompt({"Nh·∫≠p t√™n r·ªìng ƒë·ªÉ t√¨m:"}, {""}, {"text"})
    if not input then return nil end

    local filtered = filterDragonList(data, input[1])
    if #filtered == 0 then
        gg.alert("Kh√¥ng t√¨m th·∫•y r·ªìng n√†o ph√π h·ª£p.")
        return nil
    end

    return chooseDragon(filtered)
end

-- H√†m ch√≠nh
function main()
    local input1 = inputAndChooseDragon()
    if not input1 then return end

    gg.clearResults()
    gg.searchNumber(tostring(input1) .. ";-1;0::", gg.TYPE_DWORD)
    gg.refineNumber(tostring(input1), gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1)
    local results = gg.getResults(100)
    if #results == 0 then
        gg.alert("Kh√¥ng t√¨m th·∫•y chu·ªói c·∫ßn t√¨m!")
        return
    end

    for i, v in ipairs(results) do
        if v.value == input1 then
            v.value = input1
        end
    end
    gg.setValues(results)

    local extra = {}
    for i, v in ipairs(results) do
        table.insert(extra, {
            address = v.address + 4 * 3,
            flags = gg.TYPE_DWORD,
            value = i
        })
    end
    gg.setValues(extra)
    gg.toast("ƒê√£ x·ª≠ l√Ω xong m√£ r·ªìng: " .. input1)
end

main()
end
function luyensk()
  local skillChoice = gg.choice({
    "1. Luy·ªán Skill 1",
    "2. Luy·ªán Skill 2",
    "3. Luy·ªán Skill 3",
    "4. Luy·ªán Skill 4"
  }, nil, "L√™n web m√† tra code r·ªìng")

  if skillChoice == 1 then
    skilldau()
  elseif skillChoice == 2 then
    skillhai()
  elseif skillChoice == 3 then
    skillba()
  elseif skillChoice == 4 then
    skillbon()
  else
    gg.toast("cmm ƒë√©o ch·ªçn √†")
  end
end
    function skilldau()
    gg.alert("luy·ªán skill 1")

-- L·∫•y d·ªØ li·ªáu r·ªìng t·ª´ trang web
-- Bi·∫øn to√†n c·ª•c
local started = false
local input1Global = nil
local input2Global = nil
local waitingForInput2 = false

-- L·∫•y d·ªØ li·ªáu r·ªìng t·ª´ trang web
function fetchDragonData()
    local response = gg.makeRequest("https://raw.githubusercontent.com/annguyen934/an/refs/heads/main/dsrong")
    if not response or not response.content then
        gg.alert("Kh√¥ng t·∫£i ƒë∆∞·ª£c d·ªØ li·ªáu r·ªìng!")
        return nil
    end
    local data = {}
    for line in response.content:gmatch("[^\r\n]+") do
        local code, name = line:match("^(%d+)%s*%-*%s*(.+)$")
        if code and name then
            table.insert(data, {code = tonumber(code), name = name})
        end
    end
    return #data > 0 and data or nil
end

-- Ch·ªâ g·ªçi h·ªôp tho·∫°i t√¨m ki·∫øm khi user nh·∫•n l·∫°i GG
function searchDragonCode(data, title)
    local input = gg.prompt({title or "Nh·∫≠p t√™n r·ªìng:"}, {""}, {"text"})
    if not input then return nil end
    local searchTerm = input[1]:lower()
    local list, codes = {}, {}
    for _, d in ipairs(data) do
        if d.name:lower():find(searchTerm, 1, true) then
            table.insert(list, d.code .. " - " .. d.name)
            table.insert(codes, d.code)
        end
    end
    if #list == 0 then
        gg.alert("Kh√¥ng t√¨m th·∫•y r·ªìng!")
        return nil
    end
    local choice = gg.choice(list, nil, title or "Ch·ªçn r·ªìng:")
    return choice and tonumber(codes[choice]) or nil
end

-- X·ª≠ l√Ω input1: t√¨m chu·ªói, l·ªçc, s·ª≠a 1011+
function handleInput1AndReplace()
    local data = fetchDragonData()
    if not data then return nil end

    input1Global = searchDragonCode(data, "T√¨m r·ªìng ƒë·∫ßu ti√™n (input1):")
    if not input1Global then
        gg.toast("H·ªßy input1, nh·∫•n l·∫°i GG ƒë·ªÉ ti·∫øp t·ª•c.")
        return
    end

    gg.clearResults()
    local searchStr = tostring(input1Global) .. ";-1;0::"
    gg.searchNumber(searchStr, gg.TYPE_DWORD)
    gg.refineNumber(tostring(input1Global), gg.TYPE_DWORD)

    local results = gg.getResults(500)
    if #results == 0 then
        gg.alert("Kh√¥ng t√¨m th·∫•y chu·ªói input1!")
        return
    end

    -- S·ª≠a th√†nh 1011, 1012,...
    for i = 1, #results do
        results[i].value = 1010 + i
    end
    gg.setValues(results)

    gg.setVisible(false)
    started = true
    waitingForInput2 = true
    gg.toast("Xong input1. M·ªü GG ƒë·ªÉ ti·∫øp t·ª•c input2.")
end

-- Khi m·ªü l·∫°i GG: ch·ªçn input2, thay th·∫ø, sao ch√©p offset 12 -> 13,14,15
function handleInput2AndCopyOffsets()
    local data = fetchDragonData()
    if not data then return end

    input2Global = searchDragonCode(data, "T√¨m r·ªìng th·ª© hai (input2):")
    if not input2Global then
        gg.toast("H·ªßy input2, m·ªü l·∫°i GG ƒë·ªÉ ti·∫øp t·ª•c.")
        return
    end

    gg.refineNumber(tostring(input2Global), gg.TYPE_DWORD)
    local results = gg.getResults(500)
    if #results == 0 then
        gg.alert("Kh√¥ng t√¨m th·∫•y input2 trong b·ªô nh·ªõ!")
        return
    end

    for i = 1, #results do
        results[i].value = input1Global
    end
    gg.setValues(results)

    local baseEntry = nil
    for _, r in ipairs(results) do
        if r.value == input1Global then
            baseEntry = r
            break
        end
    end
    if not baseEntry then
        gg.alert("Kh√¥ng t√¨m th·∫•y ƒë·ªãa ch·ªâ ch·ª©a input1!")
        return
    end

    gg.gotoAddress(baseEntry.address)

    local addr = baseEntry.address
    local offset12 = addr + 4 * 12
    local offset13 = addr + 4 * 13
    local offset14 = addr + 4 * 14
    local offset15 = addr + 4 * 15

    -- Copy offset 12 -> 13,14,15
    local val12 = gg.getValues({{address = offset12, flags = gg.TYPE_DWORD}})[1].value

    local toWrite = {
        {address = offset13, flags = gg.TYPE_DWORD, value = val12},
        {address = offset14, flags = gg.TYPE_DWORD, value = val12},
        {address = offset15, flags = gg.TYPE_DWORD, value = val12},
    }

    gg.setValues(toWrite)
    gg.toast("ƒê√£ copy offset 12 v√†o 13,14,15.")
    started = false
    waitingForInput2 = false
    input1Global = nil
    input2Global = nil
end

-- Ch·∫°y l·∫ßn ƒë·∫ßu
handleInput1AndReplace()

-- L·∫∑p ƒë·ª£i GG hi·ªán l·∫°i
while true do
    if gg.isVisible(true) then
        gg.setVisible(false)
        if started and waitingForInput2 then
            handleInput2AndCopyOffsets()
        elseif not started then
            handleInput1AndReplace()
        end
        end
        end
    end
function skillhai()
gg.alert("luy·ªán skill 2")

-- L·∫•y d·ªØ li·ªáu r·ªìng t·ª´ trang web
-- Bi·∫øn to√†n c·ª•c
local started = false
local input1Global = nil
local input2Global = nil
local waitingForInput2 = false

-- L·∫•y d·ªØ li·ªáu r·ªìng t·ª´ trang web
function fetchDragonData()
    local response = gg.makeRequest("https://raw.githubusercontent.com/annguyen934/an/refs/heads/main/dsrong")
    if not response or not response.content then
        gg.alert("Kh√¥ng t·∫£i ƒë∆∞·ª£c d·ªØ li·ªáu r·ªìng!")
        return nil
    end
    local data = {}
    for line in response.content:gmatch("[^\r\n]+") do
        local code, name = line:match("^(%d+)%s*%-*%s*(.+)$")
        if code and name then
            table.insert(data, {code = tonumber(code), name = name})
        end
    end
    return #data > 0 and data or nil
end

-- H·ªôp tho·∫°i t√¨m ki·∫øm r·ªìng
function searchDragonCode(data, title)
    local input = gg.prompt({title or "Nh·∫≠p t√™n r·ªìng:"}, {""}, {"text"})
    if not input then return nil end
    local searchTerm = input[1]:lower()
    local list, codes = {}, {}
    for _, d in ipairs(data) do
        if d.name:lower():find(searchTerm, 1, true) then
            table.insert(list, d.code .. " - " .. d.name)
            table.insert(codes, d.code)
        end
    end
    if #list == 0 then
        gg.alert("Kh√¥ng t√¨m th·∫•y r·ªìng!")
        return nil
    end
    local choice = gg.choice(list, nil, title or "Ch·ªçn r·ªìng:")
    return choice and tonumber(codes[choice]) or nil
end

-- X·ª≠ l√Ω input1: t√¨m chu·ªói, l·ªçc, s·ª≠a 1011+
function handleInput1AndReplace()
    local data = fetchDragonData()
    if not data then return nil end

    input1Global = searchDragonCode(data, "T√¨m r·ªìng ƒë·∫ßu ti√™n (input1):")
    if not input1Global then
        gg.toast("H·ªßy input1, nh·∫•n l·∫°i GG ƒë·ªÉ ti·∫øp t·ª•c.")
        return
    end

    gg.clearResults()
    local searchStr = tostring(input1Global) .. ";-1;0::"
    gg.searchNumber(searchStr, gg.TYPE_DWORD)
    gg.refineNumber(tostring(input1Global), gg.TYPE_DWORD)

    local results = gg.getResults(500)
    if #results == 0 then
        gg.alert("Kh√¥ng t√¨m th·∫•y chu·ªói input1!")
        return
    end

    -- S·ª≠a th√†nh 1011, 1012,...
    for i = 1, #results do
        results[i].value = 1010 + i
    end
    gg.setValues(results)

    gg.setVisible(false)
    started = true
    waitingForInput2 = true
    gg.toast("Xong input1. M·ªü GG ƒë·ªÉ ti·∫øp t·ª•c input2.")
end

-- Khi m·ªü l·∫°i GG: ch·ªçn input2, thay th·∫ø, sao ch√©p offset 13 ‚Üí 12,14,15
function handleInput2AndCopyOffsets()
    local data = fetchDragonData()
    if not data then return end

    input2Global = searchDragonCode(data, "T√¨m r·ªìng th·ª© hai (input2):")
    if not input2Global then
        gg.toast("H·ªßy input2, m·ªü l·∫°i GG ƒë·ªÉ ti·∫øp t·ª•c.")
        return
    end

    gg.refineNumber(tostring(input2Global), gg.TYPE_DWORD)
    local results = gg.getResults(500)
    if #results == 0 then
        gg.alert("Kh√¥ng t√¨m th·∫•y input2 trong b·ªô nh·ªõ!")
        return
    end

    for i = 1, #results do
        results[i].value = input1Global
    end
    gg.setValues(results)

    local baseEntry = nil
    for _, r in ipairs(results) do
        if r.value == input1Global then
            baseEntry = r
            break
        end
    end
    if not baseEntry then
        gg.alert("Kh√¥ng t√¨m th·∫•y ƒë·ªãa ch·ªâ ch·ª©a input1!")
        return
    end

    gg.gotoAddress(baseEntry.address)

    local addr = baseEntry.address
    local offset12 = addr + 4 * 12
    local offset13 = addr + 4 * 13
    local offset14 = addr + 4 * 14
    local offset15 = addr + 4 * 15

    -- Copy offset 13 ‚Üí d√°n v√†o 12,14,15
    local val13 = gg.getValues({{address = offset13, flags = gg.TYPE_DWORD}})[1].value

    local toWrite = {
        {address = offset12, flags = gg.TYPE_DWORD, value = val13},
        {address = offset14, flags = gg.TYPE_DWORD, value = val13},
        {address = offset15, flags = gg.TYPE_DWORD, value = val13},
    }

    gg.setValues(toWrite)
    gg.toast("ƒê√£ copy offset 13 v√†o 12,14,15.")
    started = false
    waitingForInput2 = false
    input1Global = nil
    input2Global = nil
end

-- Ch·∫°y l·∫ßn ƒë·∫ßu
handleInput1AndReplace()

-- L·∫∑p ch·ªù m·ªü l·∫°i GG
while true do
    if gg.isVisible(true) then
        gg.setVisible(false)
        if started and waitingForInput2 then
            handleInput2AndCopyOffsets()
        elseif not started then
            handleInput1AndReplace()
        end
    end
end
end
function skillba()
gg.alert("skill 3")

-- -- Bi·∫øn to√†n c·ª•c
local started = false
local input1Global = nil
local input2Global = nil
local waitingForInput2 = false

-- L·∫•y d·ªØ li·ªáu r·ªìng t·ª´ trang web
function fetchDragonData()
    local response = gg.makeRequest("https://raw.githubusercontent.com/annguyen934/an/refs/heads/main/dsrong")
    if not response or not response.content then
        gg.alert("Kh√¥ng t·∫£i ƒë∆∞·ª£c d·ªØ li·ªáu r·ªìng!")
        return nil
    end
    local data = {}
    for line in response.content:gmatch("[^\r\n]+") do
        local code, name = line:match("^(%d+)%s*%-*%s*(.+)$")
        if code and name then
            table.insert(data, {code = tonumber(code), name = name})
        end
    end
    return #data > 0 and data or nil
end

-- H·ªôp tho·∫°i t√¨m ki·∫øm r·ªìng
function searchDragonCode(data, title)
    local input = gg.prompt({title or "Nh·∫≠p t√™n r·ªìng:"}, {""}, {"text"})
    if not input then return nil end
    local searchTerm = input[1]:lower()
    local list, codes = {}, {}
    for _, d in ipairs(data) do
        if d.name:lower():find(searchTerm, 1, true) then
            table.insert(list, d.code .. " - " .. d.name)
            table.insert(codes, d.code)
        end
    end
    if #list == 0 then
        gg.alert("Kh√¥ng t√¨m th·∫•y r·ªìng!")
        return nil
    end
    local choice = gg.choice(list, nil, title or "Ch·ªçn r·ªìng:")
    return choice and tonumber(codes[choice]) or nil
end

-- X·ª≠ l√Ω input1: t√¨m chu·ªói, l·ªçc, s·ª≠a 1011+
function handleInput1AndReplace()
    local data = fetchDragonData()
    if not data then return nil end

    input1Global = searchDragonCode(data, "T√¨m r·ªìng ƒë·∫ßu ti√™n (input1):")
    if not input1Global then
        gg.toast("H·ªßy input1, nh·∫•n l·∫°i GG ƒë·ªÉ ti·∫øp t·ª•c.")
        return
    end

    gg.clearResults()
    local searchStr = tostring(input1Global) .. ";-1;0::"
    gg.searchNumber(searchStr, gg.TYPE_DWORD)
    gg.refineNumber(tostring(input1Global), gg.TYPE_DWORD)

    local results = gg.getResults(500)
    if #results == 0 then
        gg.alert("Kh√¥ng t√¨m th·∫•y chu·ªói input1!")
        return
    end

    -- S·ª≠a th√†nh 1011, 1012,...
    for i = 1, #results do
        results[i].value = 1010 + i
    end
    gg.setValues(results)

    gg.setVisible(false)
    started = true
    waitingForInput2 = true
    gg.toast("Xong input1. M·ªü GG ƒë·ªÉ ti·∫øp t·ª•c input2.")
end

-- Khi m·ªü l·∫°i GG: ch·ªçn input2, thay th·∫ø, sao ch√©p offset 14 ‚Üí 12,13,15
function handleInput2AndCopyOffsets()
    local data = fetchDragonData()
    if not data then return end

    input2Global = searchDragonCode(data, "T√¨m r·ªìng th·ª© hai (input2):")
    if not input2Global then
        gg.toast("H·ªßy input2, m·ªü l·∫°i GG ƒë·ªÉ ti·∫øp t·ª•c.")
        return
    end

    gg.refineNumber(tostring(input2Global), gg.TYPE_DWORD)
    local results = gg.getResults(500)
    if #results == 0 then
        gg.alert("Kh√¥ng t√¨m th·∫•y input2 trong b·ªô nh·ªõ!")
        return
    end

    for i = 1, #results do
        results[i].value = input1Global
    end
    gg.setValues(results)

    local baseEntry = nil
    for _, r in ipairs(results) do
        if r.value == input1Global then
            baseEntry = r
            break
        end
    end
    if not baseEntry then
        gg.alert("Kh√¥ng t√¨m th·∫•y ƒë·ªãa ch·ªâ ch·ª©a input1!")
        return
    end

    gg.gotoAddress(baseEntry.address)

    local addr = baseEntry.address
    local offset12 = addr + 4 * 12
    local offset13 = addr + 4 * 13
    local offset14 = addr + 4 * 14
    local offset15 = addr + 4 * 15

    -- Copy offset 14 ‚Üí d√°n v√†o 12,13,15
    local val14 = gg.getValues({{address = offset14, flags = gg.TYPE_DWORD}})[1].value

    local toWrite = {
        {address = offset12, flags = gg.TYPE_DWORD, value = val14},
        {address = offset13, flags = gg.TYPE_DWORD, value = val14},
        {address = offset15, flags = gg.TYPE_DWORD, value = val14},
    }

    gg.setValues(toWrite)
    gg.toast("ƒê√£ copy offset 14 v√†o 12,13,15.")
    started = false
    waitingForInput2 = false
    input1Global = nil
    input2Global = nil
end

-- Ch·∫°y l·∫ßn ƒë·∫ßu
handleInput1AndReplace()

-- L·∫∑p ch·ªù m·ªü l·∫°i GG
while true do
    if gg.isVisible(true) then
        gg.setVisible(false)
        if started and waitingForInput2 then
            handleInput2AndCopyOffsets()
        elseif not started then
            handleInput1AndReplace()
        end
    end
end
end
function skillbon()
gg.alert("skill 4")

-- L·∫•y d·ªØ li·ªáu r·ªìng t·ª´ trang web
-- Bi·∫øn to√†n c·ª•c
local started = false
local input1Global = nil
local input2Global = nil
local waitingForInput2 = false

-- L·∫•y d·ªØ li·ªáu r·ªìng t·ª´ trang web
function fetchDragonData()
    local response = gg.makeRequest("https://raw.githubusercontent.com/annguyen934/an/refs/heads/main/dsrong")
    if not response or not response.content then
        gg.alert("Kh√¥ng t·∫£i ƒë∆∞·ª£c d·ªØ li·ªáu r·ªìng!")
        return nil
    end
    local data = {}
    for line in response.content:gmatch("[^\r\n]+") do
        local code, name = line:match("^(%d+)%s*%-*%s*(.+)$")
        if code and name then
            table.insert(data, {code = tonumber(code), name = name})
        end
    end
    return #data > 0 and data or nil
end

-- Ch·ªâ g·ªçi h·ªôp tho·∫°i t√¨m ki·∫øm khi user nh·∫•n l·∫°i GG (kh√¥ng l·∫∑p ngay)
function searchDragonCode(data, title)
    local input = gg.prompt({title or "Nh·∫≠p t√™n r·ªìng:"}, {""}, {"text"})
    if not input then return nil end
    local searchTerm = input[1]:lower()
    local list, codes = {}, {}
    for _, d in ipairs(data) do
        if d.name:lower():find(searchTerm, 1, true) then
            table.insert(list, d.code .. " - " .. d.name)
            table.insert(codes, d.code)
        end
    end
    if #list == 0 then
        gg.alert("Kh√¥ng t√¨m th·∫•y r·ªìng!")
        return nil
    end
    local choice = gg.choice(list, nil, title or "Ch·ªçn r·ªìng:")
    return choice and tonumber(codes[choice]) or nil
end

-- X·ª≠ l√Ω input1: t√¨m chu·ªói, l·ªçc, s·ª≠a 1011+
function handleInput1AndReplace()
    local data = fetchDragonData()
    if not data then return nil end

    input1Global = searchDragonCode(data, "T√¨m r·ªìng ƒë·∫ßu ti√™n (input1):")
    if not input1Global then
        gg.toast("H·ªßy input1, nh·∫•n l·∫°i GG ƒë·ªÉ ti·∫øp t·ª•c.")
        return
    end

    gg.clearResults()
    local searchStr = tostring(input1Global) .. ";-1;0::"
    gg.searchNumber(searchStr, gg.TYPE_DWORD)
    gg.refineNumber(tostring(input1Global), gg.TYPE_DWORD)

    local results = gg.getResults(500)
    if #results == 0 then
        gg.alert("Kh√¥ng t√¨m th·∫•y chu·ªói input1!")
        return
    end

    -- S·ª≠a th√†nh 1011, 1012,...
    for i = 1, #results do
        results[i].value = 1010 + i
    end
    gg.setValues(results)

    gg.setVisible(false)
    started = true
    waitingForInput2 = true
    gg.toast("Xong input1. M·ªü GG ƒë·ªÉ ti·∫øp t·ª•c input2.")
end

-- Khi m·ªü l·∫°i GG: ch·ªçn input2, thay th·∫ø, sao ch√©p offset
function handleInput2AndCopyOffsets()
    local data = fetchDragonData()
    if not data then return end

    input2Global = searchDragonCode(data, "T√¨m r·ªìng th·ª© hai (input2):")
    if not input2Global then
        gg.toast("H·ªßy input2, m·ªü l·∫°i GG ƒë·ªÉ ti·∫øp t·ª•c.")
        return
    end

    gg.refineNumber(tostring(input2Global), gg.TYPE_DWORD)
    local results = gg.getResults(500)
    if #results == 0 then
        gg.alert("Kh√¥ng t√¨m th·∫•y input2 trong b·ªô nh·ªõ!")
        return
    end

    for i = 1, #results do
        results[i].value = input1Global
    end
    gg.setValues(results)

    local baseEntry = nil
    for _, r in ipairs(results) do
        if r.value == input1Global then
            baseEntry = r
            break
        end
    end
    if not baseEntry then
        gg.alert("Kh√¥ng t√¨m th·∫•y ƒë·ªãa ch·ªâ ch·ª©a input1!")
        return
    end

    gg.gotoAddress(baseEntry.address)

    local addr = baseEntry.address
    local offset12 = addr + 4 * 12
    local offset13 = addr + 4 * 13
    local offset14 = addr + 4 * 14
    local offset15 = addr + 4 * 15

    local val15 = gg.getValues({{address = offset15, flags = gg.TYPE_DWORD}})[1].value

    local toWrite = {
        {address = offset12, flags = gg.TYPE_DWORD, value = val15},
        {address = offset13, flags = gg.TYPE_DWORD, value = val15},
        {address = offset14, flags = gg.TYPE_DWORD, value = val15},
    }

    gg.setValues(toWrite)
    gg.toast("ƒê√£ copy offset 15 v√†o 12,13,14.")
    started = false
    waitingForInput2 = false
    input1Global = nil
    input2Global = nil
end

-- Ch·∫°y l·∫ßn ƒë·∫ßu
handleInput1AndReplace()

-- L·∫∑p ƒë·ª£i GG hi·ªán l·∫°i
while true do
    if gg.isVisible(true) then
        gg.setVisible(false)
        if started and waitingForInput2 then
            handleInput2AndCopyOffsets()
        elseif not started then
            handleInput1AndReplace()
        end
    end
end

main()

while true do
    if gg.isVisible(true) and started then
        gg.setVisible(false)
        onGGVisible(input1Global)
        started = false
    end
end
  end
-- Ch·∫°y menu
while true do
  if gg.isVisible(true) then
    gg.setVisible(false)
    mainMenu()
  end
  end
